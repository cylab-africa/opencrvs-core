# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.
#
# OpenCRVS is also distributed under the terms of the Civil Registration
# & Healthcare Disclaimer located at http://opencrvs.org/license.
#
# Copyright (C) The OpenCRVS Authors located at https://github.com/opencrvs/opencrvs-core/blob/master/AUTHORS.
enum RegStatus {
  IN_PROGRESS
  ARCHIVED
  DECLARED
  DECLARATION_UPDATED
  WAITING_VALIDATION
  CORRECTION_REQUESTED
  VALIDATED
  REGISTERED
  CERTIFIED
  REJECTED
  ISSUED
}

enum RegAction {
  VERIFIED
  ASSIGNED
  UNASSIGNED
  REINSTATED
  REQUESTED_CORRECTION
  APPROVED_CORRECTION
  REJECTED_CORRECTION
  CORRECTED
  DOWNLOADED
  VIEWED
  MARKED_AS_DUPLICATE
  MARKED_AS_NOT_DUPLICATE
  FLAGGED_AS_POTENTIAL_DUPLICATE
}

enum PaymentType {
  MANUAL
}

# @todo
enum Event {
  birth
  death
  marriage
}

enum PaymentOutcomeType {
  COMPLETED
  ERROR
  PARTIAL
}

input PaymentInput {
  paymentId: ID
  type: PaymentType
  amount: Float
  outcome: PaymentOutcomeType
  date: Date
  data: String
}

type Payment {
  id: ID!
  type: PaymentType!
  amount: Float!
  outcome: PaymentOutcomeType!
  date: Date!
  attachmentURL: String
}

input MedicalPractitionerInput { # -> Encounter.participant
  name: String # -> Encounter.participant.individual(Practitioner).name
  qualification: String # -> Encounter.participant.individual(Practitioner).qualification
  lastVisitDate: Date # -> Encounter.participant.preriod.start
}

type MedicalPractitioner { # -> Encounter.participant
  name: String # -> Encounter.participant.individual(Practitioner).name
  qualification: String # -> Encounter.participant.individual(Practitioner).qualification
  lastVisitDate: Date # -> Encounter.participant.preriod.start
}

input CommentInput {
  user: UserInput
  comment: String
  createdAt: Date
}

type Comment { # Annotation
  id: ID!
  user: User # -> .authorString
  comment: String # -> .text
  createdAt: Date # -> .time
}

type StatusReason {
  text: String
}

input RegWorkflowInput {
  type: RegStatus
  user: UserInput
  timestamp: Date
  reason: String
  comments: [CommentInput]
  location: LocationInput
  timeLoggedMS: Int
}

type RegWorkflow { # Task
  id: ID!
  type: RegStatus # -> .businessStatus
  user: User # -> extension(url='http://opencrvs.org/specs/extension/regLastUser').valueReference
  timestamp: Date # -> lastModified
  comments: [Comment] # -> .note
  reason: String # -> .reason.text
  location: Location # -> extension(url='http://opencrvs.org/specs/extension/regLastOffice').valueReference.partOf
  office: Location # -> extension(url='http://opencrvs.org/specs/extension/regLastOffice').valueReference
  timeLogged: Int # -> from metrics
}

type DuplicatesInfo {
  compositionId: ID
  trackingId: String
}

type InputOutput {
  valueCode: String!
  valueId: String!
  value: FieldValue!
}

type IntegratedSystem {
  name: String
  username: String
  type: String
}

type Attachment {
  contentType: String!
  uri: String!
  description: String!
}

type EventData {
  id: ID!
  type: String!
  createdAt: String!
  actions: [Action!]!
  # Derived "easy to use" fields
  duplicates: [ID!]!
  attachments: [Attachment!]!
  status: RegStatus!
}
type Field {
  fieldId: String!
  value: String!
}
type Action {
  type: RegAction!
  createdBy: String!
  createdAt: String!
  createdAtLocation: String!
  fields: [Field!]!
}

input FieldsInput {
  fieldId: String!
  value: String!
}

input ActionsInput {
  type: String!
  fields: [FieldsInput!]!
}

input EventInput {
  id: String
  type: String
  actions: [ActionsInput]
}

input CertificateInput {
  collector: RelatedPersonInput
  hasShowedVerifiedDocument: Boolean
  payments: [PaymentInput]
  data: String
}

type Certificate { # -> Document Reference
  collector: RelatedPerson # -> .extension
  hasShowedVerifiedDocument: Boolean # -> .extension
  payments: [Payment] # -> .extension
  data: String # -> .content.attachment.data base64
}

input QuestionnaireQuestionInput {
  fieldId: String
  value: String
}

type QuestionnaireQuestion {
  fieldId: String
  value: String
}

type EventResultSet {
  results: [EventData]
  totalItems: Int
}

type DeathRegResultSet {
  results: [DeathRegistration]
  totalItems: Int
}

type EventRegResultSet {
  results: [EventData]
  totalItems: Int
}

type EventRegCount {
  count: Int
}

type RegistrationCount {
  declared: Int
  rejected: Int
}

type StatusWiseRegistrationCount {
  status: String!
  count: Int!
}

type RegistrationCountResult {
  results: [StatusWiseRegistrationCount]!
  total: Int!
}

type CreatedIds {
  compositionId: String
  trackingId: String
  isPotentiallyDuplicate: Boolean
}

type Reinstated {
  taskEntryResourceID: ID!
  registrationStatus: RegStatus
}

type Query {
  fetchEvent(id: ID!): EventData
  fetchEventForViewing(id: ID!): EventData
  fetchRegistrationCountByStatus(
    status: [String]!
    locationId: String
    event: Event
  ): RegistrationCountResult
  fetchRecordDetailsForVerification(id: String!): EventData
}

# import Mutation.* from 'correction.graphql'

type Mutation {
  createEvent(details: EventInput!): CreatedIds!
  # process transitions
  markEventAsUnassigned(id: ID!): EventData
  markEventAsVerified(id: ID!, details: EventInput!): EventData # updates status to 'verified' + audit? - attachments are valid and in order, ready for registration - internally call update if details exists
  markEventAsValidated(id: ID!, details: EventInput!): ID # updates status to 'validated' - registration agent has validated the declaration
  markEventAsRegistered(id: ID!, details: EventInput!): ID! # updates status to 'registered' - registration clerk has accepted the declaration, it is now official - internally call update if details exists
  markEventAsCertified(id: ID!, details: EventInput!): ID! # updates status to 'certified' - a printed certificate has been produced - internally call update if details exists
  markEventAsIssued(id: ID!, details: EventInput!): ID! # updates status to 'certified' - a printed certificate has been produced - internally call update if details exists
  markEventAsVoided(id: ID!, reason: String!, comment: String!): ID! # updated status to 'voided' - the registration was captured in error
  markEventAsReinstated(id: ID!): Reinstated # updates status to 'reinstated'
  markEventAsNotDuplicate(id: ID!): ID! # removes duplicates from composition
  markEventAsArchived(
    id: ID!
    reason: String
    comment: String
    duplicateTrackingId: String
  ): ID! # updates status to 'archived'
  markEventAsDuplicate(
    id: ID!
    reason: String!
    comment: String
    duplicateTrackingId: String
  ): ID!
}
